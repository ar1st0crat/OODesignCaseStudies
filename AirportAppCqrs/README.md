# Вариант упрощенной реализации приложения на основе паттерна CQRS

![pic1](https://github.com/ar1st0crat/OODesignCaseStudies/blob/master/Images/CQRS_diagram.png)

В основе паттерна лежит разделение всех операций на изменяющие (команды, commands) и читающие (запросы, queries), но это только начало...

- CQS - на уровне функций (более общий, первоначально сформулированный подход)
- CQRS - на уровне объектов

*CRUD (Create, Read, Update, Delete):*

- *Commands: Create, Update, Delete*
- *Queries: Read*


Некоторые замечания:

1) данные подсистемы чтения и подсистемы записи, в общем случае, хранятся в разных местах (и это одна из сильных сторон подхода). Но в данном примере, чтобы не перегружать материал, используется один MockRepository для хранения заглушечных данных в RAM и для read-модели, и для write-модели.

2) нужна система управления командами, запросами и уведомлениями (генерация, подписка, обработка). Можно ее написать с нуля, но есть хорошая библиотека ```MediatR```, которая делает все, что нужно для CQRS, на основе паттерна "Медиатор".

3) часто CQRS применяется в связке с подходом Event Sourcing, который можно грубо сравнить с системой контроля версий, где в качестве версий выступают все события/уведомления, связанные с изменением состояния компонентов системы; они хранятся в каком-то постоянном хранилище, например, БД. Для получения текущего состояния системы последовательно "накатываются" все изменения, хранящиеся в базе, начиная с исходного. Периодически делаются snapshots (чтобы не проигрывать все изменения от самого начала).
